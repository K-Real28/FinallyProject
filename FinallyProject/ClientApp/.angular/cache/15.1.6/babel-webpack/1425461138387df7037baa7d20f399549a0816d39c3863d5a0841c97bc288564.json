{"ast":null,"code":"//----------------------\n// <auto-generated>\n//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)\n// </auto-generated>\n//----------------------\n/* tslint:disable */\n/* eslint-disable */\n// ReSharper disable InconsistentNaming\nimport { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\nimport { InjectionToken } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport const API_BASE_URL = new InjectionToken('API_BASE_URL');\nexport class Client {\n  constructor(http, baseUrl) {\n    this.jsonParseReviver = undefined;\n    this.http = http;\n    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n  }\n  /**\r\n   * @return Success\r\n   */\n  getCity() {\n    let url_ = this.baseUrl + \"/Cities/GetCity\";\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Accept\": \"text/plain\"\n      })\n    };\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processGetCity(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processGetCity(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processGetCity(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        let result200 = null;\n        let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\n        if (Array.isArray(resultData200)) {\n          result200 = [];\n          for (let item of resultData200) result200.push(WeatherForecast.fromJS(item));\n        } else {\n          result200 = null;\n        }\n        return _observableOf(result200);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n  /**\r\n   * @return Success\r\n   */\n  weatherForecast() {\n    let url_ = this.baseUrl + \"/WeatherForecast\";\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Accept\": \"text/plain\"\n      })\n    };\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processWeatherForecast(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processWeatherForecast(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processWeatherForecast(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        let result200 = null;\n        let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\n        if (Array.isArray(resultData200)) {\n          result200 = [];\n          for (let item of resultData200) result200.push(WeatherForecast.fromJS(item));\n        } else {\n          result200 = null;\n        }\n        return _observableOf(result200);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n}\nClient.ɵfac = function Client_Factory(t) {\n  return new (t || Client)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(API_BASE_URL, 8));\n};\nClient.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: Client,\n  factory: Client.ɵfac\n});\nexport class WeatherForecast {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n  init(_data) {\n    if (_data) {\n      this.date = _data[\"date\"] ? new Date(_data[\"date\"].toString()) : undefined;\n      this.temperatureC = _data[\"temperatureC\"];\n      this.temperatureF = _data[\"temperatureF\"];\n      this.summary = _data[\"summary\"];\n    }\n  }\n  static fromJS(data) {\n    data = typeof data === 'object' ? data : {};\n    let result = new WeatherForecast();\n    result.init(data);\n    return result;\n  }\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"date\"] = this.date ? formatDate(this.date) : undefined;\n    data[\"temperatureC\"] = this.temperatureC;\n    data[\"temperatureF\"] = this.temperatureF;\n    data[\"summary\"] = this.summary;\n    return data;\n  }\n}\nfunction formatDate(d) {\n  return d.getFullYear() + '-' + (d.getMonth() < 9 ? '0' + (d.getMonth() + 1) : d.getMonth() + 1) + '-' + (d.getDate() < 10 ? '0' + d.getDate() : d.getDate());\n}\nexport class ApiException extends Error {\n  constructor(message, status, response, headers, result) {\n    super();\n    this.isApiException = true;\n    this.message = message;\n    this.status = status;\n    this.response = response;\n    this.headers = headers;\n    this.result = result;\n  }\n  static isApiException(obj) {\n    return obj.isApiException === true;\n  }\n}\nfunction throwException(message, status, response, headers, result) {\n  if (result !== null && result !== undefined) return _observableThrow(result);else return _observableThrow(new ApiException(message, status, response, headers, null));\n}\nfunction blobToText(blob) {\n  return new Observable(observer => {\n    if (!blob) {\n      observer.next(\"\");\n      observer.complete();\n    } else {\n      let reader = new FileReader();\n      reader.onload = event => {\n        observer.next(event.target.result);\n        observer.complete();\n      };\n      reader.readAsText(blob);\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["mergeMap","_observableMergeMap","catchError","_observableCatch","Observable","throwError","_observableThrow","of","_observableOf","InjectionToken","HttpClient","HttpHeaders","HttpResponse","HttpResponseBase","API_BASE_URL","Client","constructor","http","baseUrl","undefined","getCity","url_","replace","options_","observe","responseType","headers","request","pipe","response_","processGetCity","e","response","status","responseBlob","body","error","Blob","_headers","key","keys","get","blobToText","_responseText","result200","resultData200","JSON","parse","jsonParseReviver","Array","isArray","item","push","WeatherForecast","fromJS","throwException","weatherForecast","processWeatherForecast","factory","data","property","hasOwnProperty","init","_data","date","Date","toString","temperatureC","temperatureF","summary","result","toJSON","formatDate","d","getFullYear","getMonth","getDate","ApiException","Error","message","isApiException","obj","blob","observer","next","complete","reader","FileReader","onload","event","target","readAsText"],"sourceRoot":"","sources":["C:\\Users\\Kirill\\source\\repos\\FinallyProject\\FinallyProject\\ClientApp\\src\\app\\services\\Client.ts"],"sourcesContent":["//----------------------\r\n// <auto-generated>\r\n//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)\r\n// </auto-generated>\r\n//----------------------\r\n\r\n/* tslint:disable */\r\n/* eslint-disable */\r\n// ReSharper disable InconsistentNaming\r\n\r\nimport { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class Client {\r\n  private http: HttpClient;\r\n  private baseUrl: string;\r\n  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n    this.http = http;\r\n    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n  }\r\n\r\n  /**\r\n   * @return Success\r\n   */\r\n  getCity(): Observable<WeatherForecast[]> {\r\n    let url_ = this.baseUrl + \"/Cities/GetCity\";\r\n    url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n    let options_ : any = {\r\n      observe: \"response\",\r\n      responseType: \"blob\",\r\n      headers: new HttpHeaders({\r\n        \"Accept\": \"text/plain\"\r\n      })\r\n    };\r\n\r\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n      return this.processGetCity(response_);\r\n    })).pipe(_observableCatch((response_: any) => {\r\n      if (response_ instanceof HttpResponseBase) {\r\n        try {\r\n          return this.processGetCity(response_ as any);\r\n        } catch (e) {\r\n          return _observableThrow(e) as any as Observable<WeatherForecast[]>;\r\n        }\r\n      } else\r\n        return _observableThrow(response_) as any as Observable<WeatherForecast[]>;\r\n    }));\r\n  }\r\n\r\n  protected processGetCity(response: HttpResponseBase): Observable<WeatherForecast[]> {\r\n    const status = response.status;\r\n    const responseBlob =\r\n      response instanceof HttpResponse ? response.body :\r\n        (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n    if (status === 200) {\r\n      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n        let result200: any = null;\r\n        let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n        if (Array.isArray(resultData200)) {\r\n          result200 = [] as any;\r\n          for (let item of resultData200)\r\n            result200!.push(WeatherForecast.fromJS(item));\r\n        }\r\n        else {\r\n          result200 = <any>null;\r\n        }\r\n        return _observableOf(result200);\r\n      }));\r\n    } else if (status !== 200 && status !== 204) {\r\n      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n      }));\r\n    }\r\n    return _observableOf(null as any);\r\n  }\r\n\r\n  /**\r\n   * @return Success\r\n   */\r\n  weatherForecast(): Observable<WeatherForecast[]> {\r\n    let url_ = this.baseUrl + \"/WeatherForecast\";\r\n    url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n    let options_ : any = {\r\n      observe: \"response\",\r\n      responseType: \"blob\",\r\n      headers: new HttpHeaders({\r\n        \"Accept\": \"text/plain\"\r\n      })\r\n    };\r\n\r\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n      return this.processWeatherForecast(response_);\r\n    })).pipe(_observableCatch((response_: any) => {\r\n      if (response_ instanceof HttpResponseBase) {\r\n        try {\r\n          return this.processWeatherForecast(response_ as any);\r\n        } catch (e) {\r\n          return _observableThrow(e) as any as Observable<WeatherForecast[]>;\r\n        }\r\n      } else\r\n        return _observableThrow(response_) as any as Observable<WeatherForecast[]>;\r\n    }));\r\n  }\r\n\r\n  protected processWeatherForecast(response: HttpResponseBase): Observable<WeatherForecast[]> {\r\n    const status = response.status;\r\n    const responseBlob =\r\n      response instanceof HttpResponse ? response.body :\r\n        (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n    if (status === 200) {\r\n      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n        let result200: any = null;\r\n        let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n        if (Array.isArray(resultData200)) {\r\n          result200 = [] as any;\r\n          for (let item of resultData200)\r\n            result200!.push(WeatherForecast.fromJS(item));\r\n        }\r\n        else {\r\n          result200 = <any>null;\r\n        }\r\n        return _observableOf(result200);\r\n      }));\r\n    } else if (status !== 200 && status !== 204) {\r\n      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n      }));\r\n    }\r\n    return _observableOf(null as any);\r\n  }\r\n}\r\n\r\nexport class WeatherForecast implements IWeatherForecast {\r\n  date?: Date;\r\n  temperatureC?: number;\r\n  readonly temperatureF?: number;\r\n  summary?: string | undefined;\r\n\r\n  constructor(data?: IWeatherForecast) {\r\n    if (data) {\r\n      for (var property in data) {\r\n        if (data.hasOwnProperty(property))\r\n          (<any>this)[property] = (<any>data)[property];\r\n      }\r\n    }\r\n  }\r\n\r\n  init(_data?: any) {\r\n    if (_data) {\r\n      this.date = _data[\"date\"] ? new Date(_data[\"date\"].toString()) : <any>undefined;\r\n      this.temperatureC = _data[\"temperatureC\"];\r\n      (<any>this).temperatureF = _data[\"temperatureF\"];\r\n      this.summary = _data[\"summary\"];\r\n    }\r\n  }\r\n\r\n  static fromJS(data: any): WeatherForecast {\r\n    data = typeof data === 'object' ? data : {};\r\n    let result = new WeatherForecast();\r\n    result.init(data);\r\n    return result;\r\n  }\r\n\r\n  toJSON(data?: any) {\r\n    data = typeof data === 'object' ? data : {};\r\n    data[\"date\"] = this.date ? formatDate(this.date) : <any>undefined;\r\n    data[\"temperatureC\"] = this.temperatureC;\r\n    data[\"temperatureF\"] = this.temperatureF;\r\n    data[\"summary\"] = this.summary;\r\n    return data;\r\n  }\r\n}\r\n\r\nexport interface IWeatherForecast {\r\n  date?: Date;\r\n  temperatureC?: number;\r\n  temperatureF?: number;\r\n  summary?: string | undefined;\r\n}\r\n\r\nfunction formatDate(d: Date) {\r\n  return d.getFullYear() + '-' +\r\n    (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +\r\n    (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());\r\n}\r\n\r\nexport class ApiException extends Error {\r\n  message: string;\r\n  status: number;\r\n  response: string;\r\n  headers: { [key: string]: any; };\r\n  result: any;\r\n\r\n  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n    super();\r\n\r\n    this.message = message;\r\n    this.status = status;\r\n    this.response = response;\r\n    this.headers = headers;\r\n    this.result = result;\r\n  }\r\n\r\n  protected isApiException = true;\r\n\r\n  static isApiException(obj: any): obj is ApiException {\r\n    return obj.isApiException === true;\r\n  }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n  if (result !== null && result !== undefined)\r\n    return _observableThrow(result);\r\n  else\r\n    return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n  return new Observable<string>((observer: any) => {\r\n    if (!blob) {\r\n      observer.next(\"\");\r\n      observer.complete();\r\n    } else {\r\n      let reader = new FileReader();\r\n      reader.onload = event => {\r\n        observer.next((event.target as any).result);\r\n        observer.complete();\r\n      };\r\n      reader.readAsText(blob);\r\n    }\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}